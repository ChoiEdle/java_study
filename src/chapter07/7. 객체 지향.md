# 7. 객체 지향(Object Oriented)<br><br>
#### 실생활을 모델링 ------------------> 클래스(Class):틀, 설계도 --> 객체(Object)
####			  추상화(Abstraction)
			 
### 1) 클래스
#### - 객체를 생성하기 위한 틀, 설계도
#### - 클래스는 필드(Field), 생성자(Constructor), 메소드(Method)로 구성됨
#### - 클래스의 구성요소는 캡슐화(Encapsulation)를 통해 내용이 보호됨

### 2) 클래스 구조
	class 클래스명 {
		//Filed : 전역변수, 필드변수, 멤버변수 등이라고 불리지만 다 같은 것(여러 언어에서 쓰는 단어를 가져다 써서)
		변수타입 변수명;			//전역변수여서 초기값은 JVM이 설정해줌
		//Constructor : 생성자 메소드 - 객체를 생성할때 호출되는 메소드, new 키워드 뒤에 선언
		public 클래스명(){		//누구나 부를수 있어야 하기 때문에 항상 public, 항상 클래스명과 동일
		//생성될 때 실행하는 기능
		} 
		//Meothod : 기능을 정의하고 호출시 객체명.메소드명 형식으로 호출
		접근제어자 반환타입(=리턴타입) method명(){
		//메소드 기능
		}
	}

### 3) 객체
#### - 클래스라는 틀을 통해 메모리 Heap에 생성됨
#### - 클래스의 생성자를 new라는 키워드 뒤에 호출하여 생성함
#### 예시)
Scanner scan1 = new Scanner(System.in);		//여기서 맨앞에 있는 Scanner가 class, new Scanner가 메모리에 있는 것(객체)<br>
Scanner scan2 = new Scanner(System.in);		//흔히 class가 설계도(붕어빵 틀), 객체가 집(붕어빵) <br>
Scanner scan3 = new Scanner(System.in);		//인스턴스나 객체나 비슷한거라고 생각하면 편하다고 함<br>
Scanner scan = new Scanner(System.in);		//new Scanner(System.in)이 생성자<br>
int a = scan.nextInt();						//scan.nextInt가 메소드<br>

#### 예제) 사자, 호랑이, 기린, 코끼리와 같은 동물의 클래스를 도출과 코드를 작성
동물 is a 사자 - X<br>
사자(객체) is a 동물(클래스) - O<br>
호랑이(객체) is a 동물(클래스) - O<br>
기린(객체) is a 동물(클래스) - O<br>
코끼리(객체) is a 동물(클래스) - O<br>

사자의 이름은 심바, 호랑이 이름은 호돌이, 기린은 기린이, 코끼리 코순이<br>
사자 has a 이름(심바):명사 - O<br>
이름(심바) has a 사자 - X<br>

사자의 나이는 5, 호랑이 2, 기린은 3, 코끼리 10<br>
사자 has a 나이:명사 - O<br>
나이 has a 사자 - X<br>

사자, 호랑이, 기린, 코끼리는 잠을 잔다.:동사 - 메소드<br>
잠을 잔다 => 사자는 잠을 잔다.(메소드 실행 기능)<br>

- 추상화를 통해 클래스 설계 : 클래스 - 동물, 객체 - 사자, 호랑이, 기린, 코끼리<br>

#### - 동물 클래스 구조
	class 동물 {
		//필드 : 전역변수 - 형식) 데이터타입 변수명 = 값;
		String 이름;
		int 나이;
		//생성자
		public 생성자명(){		//생성자명은 클래스명과 동일, 생성자는 누구나 불러올수 있어야 해서 항상 public
			//생성될 때 실행하는 기능
		}
		//메소드
		접근제어자 반환타입 메소드명() {
		잠을 잔다	//메소드 기능
		}
	}

[실습 예제]
홍길동씨는 더조은 고등학교의 성적관리 시스템을 담당하고 있다. 홍길동씨는 학생들의
시험 성적이 나오면 학생명, 국어, 영어, 수학 성적을 입력하여 한 번에 한명씩 등록한다.
성적을 수정/삭제하는 경우에는 학생명을 기준으로 검색하여 점수를 수정하거나 삭제를 진행한다.
- 명사, 동사를 도출하여 클래스를 설계해 보세요
- 명사 : 홍길동(관리자), 성적관리 시스템, 학생명, 국어, 영어, 수학
- 동사 : 등록한다. 검색한다. 수정한다. 삭제한다.

<<개념 설계>><br>
[클래스명 : 학생]<br>
Field : 학생명, 국어, 영어, 수학<br>
Constructor : 학생()<br>
method : <br>

[클래스명 : 성적관리 시스템]<br>
Field : 관리자, 학생클래스<br>
Constructor : 성적관리 시스템()<br>
method : 등록한다. 검색한다. 수정한다. 삭제한다.<br>

<<물리적 설계>><br>
[클래스명 : Student]<br>
Field : name:String, kor:int, eng:int, math:int<br>
Constructor : Student()<br>
Method : <br>

[클래스명 : ScoreMgmSystem]<br>
Field : admin:String, sname:Student<br>
Constructor : ScoreMgmSystem()<br>
Method : insert(), update(), remove(), search()<br>

[클래스명 : ScoreMgmSystemTest]<br>
Field : <br>
Contstructor : <br>
Method : main()<br>

### 4) 생성자
#### - 클래스를 통해 객체를 생성하는 역할을 진행
#### - 가장 먼저 호출되는 메소드이며, 딱 한번만 호출됨				
#### - JVM이 자동으로 호출하여 실행
#### - 호출위치는 new 생성자();
#### - 생성자 이름은 클래스명과 동일
#### - 기본 생성자(생성자())는 정의시 생략이 가능함, 단 기본 생성자만 존재하는 경우 	//괄호 안에 아무것도 없는게 기본 생성자

### 5) 메소드
#### - 객체의 기능을 담당하는 역할
#### - 메소드 정의 형식)
	접근제어자 리턴타입(반환타입) 메소드명(매개변수(파라미터)){ 		//여기서 가장 중요한건 리턴타입과 매개변수
	메소드의 기능 실행문;
	}

#### - 접근제어자 : 메소드를 호출하는 범위를 정의하는 역할(public, private, protected, default(package))
#### - 리턴타입(반환타입) : 메소드가 실행을 한 결과를 호출한 곳에 리턴(전달)하는 경우 정의
#### - 리턴값은 return 키워드 뒤에 입력함, 만약 리턴값이 없으면 void를 입력
#### 예시) getNumber() 메소드 호출 시 int 타입의 정수 100을 전달받음
	public int getNumber() {
		return 100;
	}
#### - 매개변수(파라미터) : 메소드 호출 시 메소드의 기능을 실행하기 위해 필요한 값들을 전달하는 역할
####  					실행문에서 사용되는 데이터타입을 마추어 입력을 받아야 함!!
#### 					매개변수의 갯수는 정해지지 않음, 임의로 정의 가능
####					매개변수의 데이터타입은 기본형, 참조형 모두 가능함
#### 예시) add(값1, 값2); 값1, 값2를 add 메소드 호출 시 입력받아 실행을 하는 메소드
####      add(10, 20); --> 출력 형식 : sum = 30
	public void add(int num1, int num2) {
	System.out.println("sum = " + (num + num2));
	}

#### - 리턴타입과 매개변수에 따른 메소드 정의 예 		//잘해두면 자바스크립트 함수에서도 도움이 많이 됨
#### (1) 리턴타입 X, 매개변수 X
	public void method1() {
		System.out.println("method1 --> 리턴타입 X, 매개변수 X");
	}
	호출 : method1();
	출력 : method1 --> 리턴타입 X, 매개변수 X

#### (2) 리턴타입 O, 매개변수 X
	public int method2() {
		int num1 = 10;
		int num2 = 20;
		return num1+num2;
	}
	호출 : method2();
	리턴값 : 30

#### (3) 리턴타입 X, 매개변수 O 	//매개변수가 있는 경우 타입과 갯수에 따라 메소드 오버로딩(Overloading) 구현이 가능함
	public void method3(int num1, int num2) {
		System.out.println("method3 --> " + (num1 + num2));
	}
	public void method3(String name) {
		System.out.println("method3 --> " + name);
	}
	호출 : method3(10, 20); or method3("홍길동");
	출력 : method3 --> 30   or method1 --> 홍길동

#### (4) 리턴타입 O, 매개변수 O 	//매개변수가 있는 경우 타입과 갯수에 따라 메소드 오버로딩(Overloading) 구현이 가능함
	public int method4(int num1, int num2) {
		return num1 + num2;
	}
	public String method4(String name) {
		return name;
	}
	호출 : method4(10, 20); or method4("홍길동");
	리턴값 : 30 or 홍길동

### 6) 메소드 오버로딩(Overloading)
#### - 하나의 클래스에 동일한 이름을 가진 메소드를 여러개 정의하는 것
#### - 단, 매개변수의 갯수와 타입은 서로 달라야 함
#### - 리턴타입과는 상관없음

### 7) 가변 매개변수(Variable Aguments)
#### - 매개변수 입력 시 갯수에 제한없이 동일한 데이터타입으로 입력가능
#### - 형식 : 메소드명(데이터타입 ... 변수명) { ~ }
	void method(int ... numbers) {} --> 호출 시 : method(1,2,3,4,5,6,7,8);
	void method(String ... names) {} --> 호출 시 : method("홍길동", "이순신", "김유신");
	int[] numbers = {1,2,3,4,5,6,7,8};
	void method(int numbers[]) {} --> method(numbers);

#### - 가변 매개변수(Variable Agruments)는 자바스크립트의 스프레드(spread) 연산자와 모양은 동일하지만, 기능이 조금씩 다르므로 정리필요!!!

### 



